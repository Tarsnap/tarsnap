#!/usr/bin/env python3

""" Automatically write a zsh completion file. """

import os.path
import re

import shtab

import man_to_argparse


_ZSH_PREAMBLE = r"""# Custom header for the zsh completion file for tarsnap
#
# Place this file in one of the completion folders listed in $fpath (e.g.
# /usr/share/zsh/functions/Completion/Linux or $HOME/.zsh/functions).
# Then either restart zsh, or: autoload -Uz _tarsnap; compdef _tarsnap tarsnap

# Set the following variable to the path of a file containing the output from
# "tarsnap --list-archives", i.e. one archive name per line.  If left blank
# then archive names will not be completed.
local archive_list_file=

if [ -n "${archive_list_file}" ]; then
    archive_list=( ${(uf)"$(< "${archive_list_file}")"} )
else
    archive_list=
fi

"""

_AUTO_GENERATED = "# AUTOMATCALLY GENERATED by `shtab`"
_AUTO_GENERATED_US = "%s, then modified by %s" % (_AUTO_GENERATED,
                                                  os.path.basename(__file__))


def add_argtypes(zsh_output):
    """ Add special zsh completion rules for some arguments. """
    outlines = []
    for line in zsh_output.split("\n"):
        if ':"' in line:
            # Special handling for "method:arg"
            if r"method\:arg" in line:
                outlines.append(line)
                continue

            arg = line.split(":")[-2]
            argtype = man_to_argparse.get_argtypestr(arg)

            if argtype == "directory":
                line = line[:-1] + "{_files -/}\""
            elif argtype == "filename":
                line = line[:-1] + "{_files}\""
            elif argtype == "archive-name":
                line = line[:-1] + "(${archive_list}):\""

        outlines.append(line)

    zsh_output = "\n".join(outlines)
    return zsh_output


def restore_metavars(zsh_output, optlist):
    """ Replace the argument strings in zsh_output.

        shtab uses the option name as the argument string, instead of
        metavar (which is what we'd prefer).
    """
    get_option = re.compile(r"\"(.*)\[")
    get_arg = re.compile(r":(.*):\"")

    outlines = []
    for line in zsh_output.split("\n"):
        # Does the line contain an argument?
        if ':"' in line:
            opt = get_option.findall(line)[0]
            # Find the correct arg to use
            optarg = optlist.get_optarg(opt)
            # We need to escape "method:arg", but there's no harm in calling
            # this function on every arg in case something else comes up in
            # the future.
            arg = shtab.escape_zsh(optarg.arg)

            # Replace it in the line
            line = re.sub(get_arg, ":%s:\"" % arg, line)
        outlines.append(line)

    zsh_output = "\n".join(outlines)

    return zsh_output


def write_zsh(filename_zsh, options, optlist, descs):
    """ Write the options into the zsh completion file.  """
    # Get a zsh completion file.
    parser_obj, _ = man_to_argparse.generate(options, optlist, descs)
    zsh_output = shtab.complete(parser_obj, shell="zsh")

    # Remind readers that we've modified the completion file.
    zsh_output = zsh_output.replace(_AUTO_GENERATED, _AUTO_GENERATED_US)

    # Remove the false "mode" strings.
    zsh_output = zsh_output.replace("_mode", "").replace("mode", "")

    # Use argparse's 'metavar' for argument strings, instead of the 'option'.
    zsh_output = restore_metavars(zsh_output, optlist)

    # Add special argument completion rules (e.g,. "is a file", "is a dir").
    zsh_output = add_argtypes(zsh_output)

    # Add our custom preamble.
    index = zsh_output.find("# AUTO")
    zsh_output = "%s%s%s" % (zsh_output[:index], _ZSH_PREAMBLE,
                             zsh_output[index:])

    # Write final completion file
    with open(filename_zsh, "wt", encoding="utf-8") as fileobj:
        fileobj.write(zsh_output)
        fileobj.write("\n")
